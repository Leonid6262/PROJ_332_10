#include "settings_eep.hpp"
#include "lpc177x_8x_clkpwr.h"

// --- Приватный конструктор класса EEPSettings ---
// Здесь происходит начальная инициализация текущих уставок значениями по умолчанию.
// Эта инициализация происходит ОДИН РАЗ, когда создается CEEPSettings::instance.
CEEPSettings::CEEPSettings() 
{
  settings = defaultSettings;  // Делаем все уставки дефолтными.
}

// --- Singleton Майерса ---
CEEPSettings& CEEPSettings::getInstance() 
{
  static CEEPSettings instance; // Инициализация в момент первого вызова
  return instance;
}

// Загрузка уставок
StatusRet CEEPSettings::loadSettings() 
{
  WorkSettings tempSettings; 
  if (readFromEEPInternal(tempSettings) == StatusRet::SUCCESS) 
  {
    settings = tempSettings; // CRC - Ok, копируем вместо дефолтныхг
    return StatusRet::SUCCESS;
  }
  // В settings остаются дефолтные!
  return StatusRet::ERROR;
}

// Функция чтения из EEP в структуру уставок
StatusRet CEEPSettings::readFromEEPInternal(WorkSettings& outSettings) 
{
  EEPr(0, 0, reinterpret_cast<unsigned char*>(&outSettings), MODE_8_BIT, sizeof(outSettings));    //EEPROM -> RAM
  unsigned short chs_tmp = pCRC16->calc
    (
     reinterpret_cast<unsigned char*>(&outSettings) + sizeof(outSettings.checkSum), sizeof(outSettings) - sizeof(outSettings.checkSum)
       );
  if(chs_tmp != outSettings.checkSum)
  { 
    return StatusRet::ERROR; // CRC - ERROR
  }
  return StatusRet::SUCCESS; // CRC - Ok
}

// Запись уставок
void CEEPSettings::saveSettings() 
{
  writeToEEPInternal(settings);
}

// Функция записи в EEP из структуры уставок
void CEEPSettings::writeToEEPInternal(WorkSettings& inSettings) 
{
  inSettings.checkSum = pCRC16->calc
    (
     reinterpret_cast<unsigned char*>(&inSettings) + sizeof(inSettings.checkSum), sizeof(inSettings) - sizeof(inSettings.checkSum)
       );
  EEPw(0, 0, reinterpret_cast<unsigned char*>(&inSettings), MODE_8_BIT, sizeof(inSettings));      //RAM -> EEPROM
}

// Инициализируем EEPROM и получаем указатель на объект класса расчёта CRC
void CEEPSettings::init_EEP(CCRC16* pCRC16) 
{
  EEP_init();
  this->pCRC16 = pCRC16;
}

// EEP_init, EEPr, EEPw - скопированы для исключения зависимостей
void CEEPSettings::EEP_init(void)
{
    uint32_t val, cclk;
    LPC_EEPROM->PWRDWN = 0x0;
    /* EEPROM is automate turn on after reset */
    /* Setting clock:
     * EEPROM required a 375kHz. This clock is generated by dividing the
     * system bus clock.
     */
    cclk = SystemCoreClock;
    //cclk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_CPU);
    val = (cclk/375000)-1;
    LPC_EEPROM->CLKDIV = val;

    /* Setting wait state */
    val  = ((((cclk / 1000000) * 15) / 1000) + 1);
    val |= (((((cclk / 1000000) * 55) / 1000) + 1) << 8);
    val |= (((((cclk / 1000000) * 35) / 1000) + 1) << 16);
    LPC_EEPROM->WSTATE = val;
}

void CEEPSettings::EEPr(uint16_t page_offset, uint16_t page_address, void* data, EEPROM_Mode_Type mode, uint32_t count)
{
  uint32_t i;
  uint8_t *tmp8 = (uint8_t *)data;
  uint16_t *tmp16 = (uint16_t *)data;
  uint32_t *tmp32 = (uint32_t *)data;
  
  LPC_EEPROM->INT_CLR_STATUS = ((1 << EEPROM_ENDOF_RW)|(1 << EEPROM_ENDOF_PROG));
  LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(page_address)|EEPROM_PAGE_OFFSET(page_offset);
  if(mode == MODE_8_BIT)
    LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_READ|EEPROM_CMD_RDPREFETCH;
  else if(mode == MODE_16_BIT){
    LPC_EEPROM->CMD = EEPROM_CMD_16_BIT_READ|EEPROM_CMD_RDPREFETCH;
    //check page_offset
    if((page_offset &0x01)!=0)
      return;
  }
  else{
    LPC_EEPROM->CMD = EEPROM_CMD_32_BIT_READ|EEPROM_CMD_RDPREFETCH;
    //page_offset must be a multiple of 0x04
    if((page_offset & 0x03)!=0)
      return;
  }
  
  //read and store data in buffer
  for(i=0;i<count;i++){
    
    if(mode == MODE_8_BIT){
      *tmp8 = (uint8_t)(LPC_EEPROM -> RDATA);
      tmp8++;
      page_offset +=1;
    }
    else if (mode == MODE_16_BIT)
    {
      *tmp16 =  (uint16_t)(LPC_EEPROM -> RDATA);
      tmp16++;
      page_offset +=2;
    }
    else{
      *tmp32 = (uint32_t)(LPC_EEPROM ->RDATA);
      tmp32++;
      page_offset +=4;
    }
    while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_RW)&0x01));
    LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_RW);
    if((page_offset >= EEPROM_PAGE_SIZE) && (i < count - 1)) {
      page_offset = 0;
      page_address++;
      LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(page_address)|EEPROM_PAGE_OFFSET(page_offset);
      if(mode == MODE_8_BIT)
        LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_READ|EEPROM_CMD_RDPREFETCH;
      else if(mode == MODE_16_BIT)
        LPC_EEPROM->CMD = EEPROM_CMD_16_BIT_READ|EEPROM_CMD_RDPREFETCH;
      else
        LPC_EEPROM->CMD = EEPROM_CMD_32_BIT_READ|EEPROM_CMD_RDPREFETCH;
    }
  }
}

void CEEPSettings::EEPw(uint16_t page_offset, uint16_t page_address, void* data, EEPROM_Mode_Type mode, uint32_t count)
{
  uint32_t i;
  uint8_t *tmp8 = (uint8_t *)data;
  uint16_t *tmp16 = (uint16_t *)data;
  uint32_t *tmp32 = (uint32_t *)data;
  
  LPC_EEPROM->INT_CLR_STATUS = ((1 << EEPROM_ENDOF_RW)|(1 << EEPROM_ENDOF_PROG));
  //check page_offset
  if(mode == MODE_16_BIT){
    if((page_offset & 0x01)!=0) while(1);
  }
  else if(mode == MODE_32_BIT){
    if((page_offset & 0x03)!=0) while(1);
  }
  LPC_EEPROM->ADDR = EEPROM_PAGE_OFFSET(page_offset);
  for(i=0;i<count;i++)
  {
    //update data to page register
    if(mode == MODE_8_BIT){
      LPC_EEPROM->CMD = EEPROM_CMD_8_BIT_WRITE;
      LPC_EEPROM -> WDATA = *tmp8;
      tmp8++;
      page_offset +=1;
    }
    else if(mode == MODE_16_BIT){
      LPC_EEPROM->CMD = EEPROM_CMD_16_BIT_WRITE;
      LPC_EEPROM -> WDATA = *tmp16;
      tmp16++;
      page_offset +=2;
    }
    else{
      LPC_EEPROM->CMD = EEPROM_CMD_32_BIT_WRITE;
      LPC_EEPROM -> WDATA = *tmp32;
      tmp32++;
      page_offset +=4;
    }
    while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_RW)&0x01));
    LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_RW);
    if((page_offset >= EEPROM_PAGE_SIZE)|(i==count-1)){
      //update to EEPROM memory
      LPC_EEPROM->INT_CLR_STATUS = (0x1 << EEPROM_ENDOF_PROG);
      LPC_EEPROM->ADDR = EEPROM_PAGE_ADRESS(page_address);
      LPC_EEPROM->CMD = EEPROM_CMD_ERASE_PRG_PAGE;
      while(!((LPC_EEPROM->INT_STATUS >> EEPROM_ENDOF_PROG)&0x01));
      LPC_EEPROM->INT_CLR_STATUS = (1 << EEPROM_ENDOF_PROG);
    }
    if(page_offset >= EEPROM_PAGE_SIZE)
    {
      page_offset = 0;
      page_address +=1;
      LPC_EEPROM->ADDR =0;
      if(page_address > EEPROM_PAGE_NUM - 1) page_address = 0;
    }
  }
}


